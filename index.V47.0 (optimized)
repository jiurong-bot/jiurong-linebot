// index.js - V47.0（V46 + 批次推播(multicast)優化）

const express = require('express');
const fs = require('fs');
const path = require('path');
const line = require('@line/bot-sdk');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// ---------- LINE CONFIG ----------
const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.CHANNEL_SECRET,
};
const client = new line.Client(config);

// ---------- 資料快取 ----------
const DATA_FILE = './data.json';
let cache = { users: [], courses: [] }; // user object: { userId, name, ... }
let isDirty = false;

// 初始化讀取資料
function loadData() {
  try {
    if (fs.existsSync(DATA_FILE)) {
      const raw = fs.readFileSync(DATA_FILE, 'utf-8');
      cache = JSON.parse(raw);
    } else {
      cache = { users: [], courses: [] };
    }
  } catch (err) {
    console.error('讀取資料錯誤:', err);
    cache = { users: [], courses: [] };
  }
}
loadData();

// 定期寫入資料（降低 I/O 次數）
const AUTO_SAVE_INTERVAL_MS = 10000; // 10s
setInterval(() => {
  if (isDirty) {
    fs.writeFile(DATA_FILE, JSON.stringify(cache, null, 2), (err) => {
      if (err) console.error('寫入資料錯誤:', err);
      else isDirty = false;
    });
  }
}, AUTO_SAVE_INTERVAL_MS);

// 儲存快取資料（標記為 dirty）
function saveData() {
  isDirty = true;
}

// ---------- 常量與工具 ----------
const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
const tzFormatter = new Intl.DateTimeFormat('zh-TW', {
  timeZone: 'Asia/Taipei',
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit',
});

function nowInTaipei() {
  return tzFormatter.format(new Date());
}

// ---------- MULTICAST / BROADCAST 支援 ----------
// LINE multicast 最多 500 userIds 一次
const MULTICAST_LIMIT = 500;

/**
 * broadcastMessage(users, message)
 * - users: array of userId OR array of user objects containing userId (e.g. cache.users)
 * - message: LINE message object or text string
 */
async function broadcastMessage(users, message) {
  if (!Array.isArray(users) || users.length === 0) {
    throw new Error('沒有可廣播的使用者');
  }

  // 取得 userId 陣列（接受 userId 或 user 物件）
  const userIds = users.map(u => (typeof u === 'string' ? u : u.userId)).filter(Boolean);

  if (userIds.length === 0) {
    throw new Error('找不到任何 userId');
  }

  // 組裝 message 物件
  let msgObj = message;
  if (typeof message === 'string') {
    msgObj = { type: 'text', text: message };
  }

  // 切分成多批，每批不超過 MULTICAST_LIMIT
  const batches = [];
  for (let i = 0; i < userIds.length; i += MULTICAST_LIMIT) {
    batches.push(userIds.slice(i, i + MULTICAST_LIMIT));
  }

  // 並行執行每一批 multicast，並等待完成
  const results = await Promise.allSettled(batches.map(batch => client.multicast(batch, msgObj)));
  const summary = {
    totalUsers: userIds.length,
    batches: batches.length,
    successes: results.filter(r => r.status === 'fulfilled').length,
    failures: results.filter(r => r.status === 'rejected').length,
    details: results.map((r, idx) => ({ batch: idx + 1, status: r.status, reason: r.reason ? r.reason.message : null })),
  };

  return summary;
}

// ---------- LINE Webhook ----------
app.post('/webhook', line.middleware(config), async (req, res) => {
  try {
    const results = await Promise.all(req.body.events.map(handleEvent));
    res.json(results);
  } catch (err) {
    console.error('Webhook 錯誤:', err);
    res.status(500).end();
  }
});

// 處理事件
async function handleEvent(event) {
  try {
    if (event.type === 'message' && event.message.type === 'text') {
      const text = event.message.text.trim();
      const userId = event.source && event.source.userId;

      // 若是新用戶，儲存 userId（簡單邏輯，可修改為 LIFF 登入時寫入更完整資料）
      if (userId && !cache.users.find(u => u.userId === userId)) {
        cache.users.push({ userId, name: `user-${cache.users.length + 1}` });
        saveData();
      }

      // 回應“時間”
      if (text === '時間') {
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: `台北時間：${nowInTaipei()}`,
        });
      }

      // 列出學員（僅顯示名字）
      if (text === '學員名單') {
        const userList = cache.users.map(u => u.name).join(', ') || '目前沒有學員';
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: `學員名單：${userList}`,
        });
      }

      // 新增學員（範例：新增學員 小明）
      if (text.startsWith('新增學員 ')) {
        const name = text.replace('新增學員 ', '').trim();
        const userObj = { userId: userId || null, name };
        cache.users.push(userObj);
        saveData();
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: `已新增學員：${name}`,
        });
      }

      // 廣播（範例：廣播 測試訊息）
      if (text.startsWith('廣播 ')) {
        // 只有示範用途，請在實務環境加入權限檢查（例如檢查 userId 是否為管理者）
        const payload = text.replace('廣播 ', '').trim();
        try {
          const summary = await broadcastMessage(cache.users, payload);
          return client.replyMessage(event.replyToken, {
            type: 'text',
            text: `已發送廣播給 ${summary.totalUsers} 位使用者（批次 ${summary.batches} 次，成功 ${summary.successes}，失敗 ${summary.failures}）`,
          });
        } catch (err) {
          return client.replyMessage(event.replyToken, {
            type: 'text',
            text: `廣播失敗：${err.message}`,
          });
        }
      }

      // 其他指令或回應可以放在這裡...
    }

    // 非文字訊息或不處理的事件
    return Promise.resolve(null);
  } catch (err) {
    console.error('handleEvent 內錯誤:', err);
    return Promise.resolve(null);
  }
}

// ---------- Scheduler 集中管理 ----------
setInterval(() => {
  const now = new Date();
  const minutes = now.getMinutes();

  // keep-alive 每 5 分鐘
  if (minutes % 5 === 0) {
    fetchSelf();
  }

  // 其他定期任務可在此擴充
}, 60000);

// keep-alive（Node 18+ 有內建 fetch）
function fetchSelf() {
  fetch(`http://localhost:${PORT}/`)
    .then(() => console.log('自我 ping 成功'))
    .catch(err => console.error('自我 ping 失敗:', err));
}

// ---------- Routes ----------
app.get('/', (req, res) => res.send('九容瑜伽 LINE Bot 運行中 - V47.0'));

// ---------- 優雅關閉 ----------
async function gracefulShutdown(signal) {
  console.log(`收到 ${signal} 訊號，準備關閉伺服器...`);
  // 寫入最後的資料
  if (isDirty) {
    try {
      fs.writeFileSync(DATA_FILE, JSON.stringify(cache, null, 2));
      console.log('已將快取資料寫回磁碟');
    } catch (err) {
      console.error('關閉時寫入資料錯誤:', err);
    }
  }

  // 若有需要，可在這等待未完成的外部請求（例如正在進行的 multicast）
  // 這裡示範等待短暫時間再關閉（可視情況延長或改為追蹤進行中 promise）
  setTimeout(() => {
    server.close(() => {
      console.log('HTTP server 已關閉');
      process.exit(0);
    });
  }, 500);
}

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// ---------- 啟動伺服器 ----------
const server = app.listen(PORT, () => {
  console.log(`伺服器已啟動，埠號 ${PORT}`);
});
